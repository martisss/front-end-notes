## Reacthan

## 前言

2022年3月29号，`React 18`正式版发布，小明也兴冲冲地开始`hooks`学习之旅。某天他使用`codesandbox`写了一个小`demo`时，他发现组件诡异地渲染了多次，函数组件代码如下：

> count.jsx

```jsx
export default function Count() {
  const [counter, setCounter] = useState(0);
  useEffect(() => {
    console.log("effect");
    setTimeout(() => {
      setCounter(counter + 1);
    }, 3000);
  });
  console.log("before render");

  return (
    <div className="container">
      <div className="el">{counter}</div>
    </div>
  );
}
```

实现的效果很简单，每隔三秒将`count`加1，很简单对不对？

打开这个`demo`：[count + 1](https://codesandbox.io/s/hooks-hxbc7x?file=%2Fsrc%2Fcount.jsx)，同时打开控制台，你就可以看到如下输入：

`before render`与`effect`一开始都打印了两次，之后`before render`每次都诡异地打印了两次

git 表情包

这是为什么呢？经过一番查找，发现是`React.StrictMode`的锅。`React 17`文档中是这样描述 [React.StrictMode](https://zh-hans.reactjs.org/docs/strict-mode.html):

> `StrictMode` 是一个用来突出显示应用程序中潜在问题的工具。与 `Fragment` 一样，`StrictMode` 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。

`React 17`文档中关于它的作用大概可以归为两类：

- 检测副作用
- 对于在应用中使用已经废弃、过时的方法会发出警告

对于第二点，相信大家都可以理解，毕竟`React`现在都发布`18`版了，不少以前的方法已经过时或者废弃了，在较新版本的`React`中再使用这些方法肯定时不安全的。

那么对于第一点呢？

这不得不提`React 18`文档对于`StrictMode`的描述：

> React offers a “Strict Mode” in which it calls each component’s function twice during development. **By calling the component functions twice, Strict Mode helps find components that break these rules.**

大意就是在开发者模式中，`StrictMode`会将相应组件执行两次，主要目的是为了找到违背了`these rules`的组件

## useState initializer

- In Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.

## useState updater function

If you pass a function as `nextState`, it will be treated as an *updater function*. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.